## Intro to Data Structures and Algorithms
- Abstract data types or strucutres (ADTs): linked list, stack queue, graph tree ...
  - we can use these datatypes and perform operations with them, but do not know how they work internally
- common operations on data structures: insert, modify, delete, search, sort, merge, traverse...
- Non-primitive data structures:
  - linear: stores data sequentially
    - static: array
    - dynamic: linked list, stack, queue
  - non-linear: trees, graphs
    - collection of randomly distributed set of data joined by a reference pointer

## Arrays and Linked Lists
- list: ordered collection of elemeents that may occur more than once
- array: homogeneous data and fixed size
  - can be single or multidimensional
  - pros:
    - index or randomely access elements frequently
    - when low memory is required
  - cons:
    - static: array size must be known beforehand and stays fixed
    - complicated insertion and deletion: requires shifting elements
  - applications: ticketing or booking system, leaderboards for games, image/speech processing (2D)
- linked list: collection of nodes in a linear sequence
  - has memory allocated seperately for each node
  - uses pointers or references to connect nodes together
  - each element contains data and a reference to the next node
    - null reference means it is the last node in the list
  - dynamic structure: can increase or decrease size at runtime
    - no need to shift items during insertions or deletions
  - pros:
    - grows or shrinks dynamically
    - no restrictions on operations: can be done on any part of the list
    - no memory waste
  - cons:
    - more memory due to data + reference address
    - traversal is difficult (must traverse all nodes before n)
      - reverse traversal requires additional memory for pointer to reference in the opposite direction
- linked lists can be: 
  - singly (one-way)
  - doubly: both directions; includes two addresses
  - circularly linked: last node references first node; no null values; can be singly or doubly linked
- applications: not sure about number of elements, browser cache, undo/redo, track info in a circular manner (ie player turns)

## Stack and Queue
- stack: only allows access to last element inserted (or top/head)
  - last-in-first-out (LIFO)
  - functions:
    - push: add an element to top
    - pop: remove an element
    - peek: get top element
  - stack underflow: trying to pop an item from an empty stack
  - can be implemented using array or linked list
  - size of stack is fixed (item can be pushed if space is available)
  - needs a variable or pointer "top" to track top element
    - top variable = -1 means an empty stack for array or NULLL for linked list
  - applications: web browsers (history), to reverse a string, create local variables, evaluating arithmetic expressions
- queue: collection of items where we add items at one end (rear) and remove items from the other end (front)
  - first-in-first-out (FIFO)
  - application: CPU/disk scheduling, interruptions on real-time systems, phone calls in call centers, shared resource usage
  - functions:
    - enque: add an element
    - deque: remove an element
  - can be implemented using arrays and linked lists
  - linked list queues can be singly, doubly, and circularly linked (ring buffer)
    - circular queues are used for CPU scheduling, memory management, and traffic management
  - priority queue: priority assigned to each element
    - elements are deleted based on priority of the element (highest is removed first)
    - used for load balancing, interruption handling, sorting heap
  - doubly ended queue: insertion and deletion takes place at both ends
    - Input restricted deque: input is blocked at one end but allows deletion from both ends
    - Output restricted deque: output is blocked at one end but allows insertion from both ends

## Trees
- nonlinear data structures: elements not ordered sequentially and elements can be connected to more than two other elements
  - cannot be traversed in a single run
- trees are like a file or directory system (hierarchical)
- root: top node of a tree (no parent)
- predecessor = parent; successor = child
- path: sequence of successive edges from source to destination node
- degree of a node: number of its children
- dgree of a tree: highest degree of a node in that tree
- depth of a node: number of edges between that node and the root
- height of a node: longest path from a node to the leaf
- applications: compilers (expression/symbol tree), database management systems, OS file systems, org charts
- implemented using a linked list
- binary tree: node is linked to at most two successor nodes
  - used for searching, arithmetic expression, decision process
  - complete binary tree: every level except last is full and nodes are as far to the left as possible
  - full binary tree: every node has two children other than the leaves
  - binary search tree:
    - every node on left subtree is < parent node
    - every node on right subtree is >= parent node
    - major operations:
      - insert, search, delete, traversal (pre-order, in-order, post-order)
- max number of nodes on depth i = 2^i
- max nodes of height k = 2^(k+1)-1

## Recursion
- solve a problem by solving smaller problems of the same type
- a function/algorithm calls itself using smaller input values
- pros: solves difficult problems easily and provides readability
- cons: use alot of memory
- base case: condition to terminate recursion algorithm
- components:
  - decomposition: decompose the problem into smaller problems
  - composition: combining answers of smaller problems into an answer for the larger problem
  - base case: smallest problem that can be solved wihtout further decomposition
- iteration is more efficient in terms of memory/execution speed
- 
